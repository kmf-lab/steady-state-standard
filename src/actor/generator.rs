use steady_state::*;

/// State structure that persists across Actor restarts and panics.
/// Unlike local variables, SteadyState survives actor failures and maintains
/// consistency across the entire application lifecycle because it will be 
/// held by Main
pub(crate) struct GeneratorState {
    pub(crate) value: u64
}

/// Public entry point that demonstrates a dual-mode operation pattern.
/// This allows the same actor to run in production mode (internal_behavior)
/// or testing mode (simulated_behavior) based on the execution context.
pub async fn run(actor: SteadyActorShadow
                 , generated_tx: SteadyTx<u64>
                 , state: SteadyState<GeneratorState>) -> Result<(),Box<dyn Error>> {
    let actor = actor.into_spotlight([], [&generated_tx]); //#!#//
    if actor.use_internal_behavior { //always true unless testing  //#!#//
        internal_behavior(actor, generated_tx, state).await
    } else {
        //Here we listen to test messages from main and relay them as if they were 
        //generated by the actor itself.
        actor.simulated_behavior(vec!(&generated_tx)).await
    }
}

/// Internal behavior demonstrates continuous data production with backpressure handling.
/// This pattern is common for data sources that need to produce at maximum safe rate
/// while respecting downstream capacity constraints.
async fn internal_behavior<A: SteadyActor>(mut actor: A
                                           , generated_tx: SteadyTx<u64>
                                           , state: SteadyState<GeneratorState> ) -> Result<(),Box<dyn Error>> {

    // State locking provides thread-safe access with automatic initialization.
    // The closure runs only if no state exists, ensuring consistent startup behavior.
    let mut state = state.lock(|| GeneratorState {value: 0}).await; //#!#//
    // Channel is locked to this actor instance on startup. On panic/restart we will re-acquire the lock.
    let mut generated_tx = generated_tx.lock().await;

    // Shutdown coordination: mark_closed() signals downstream actors that no more data will come
    // after the current data in flight. This enables clean pipeline termination without dropping
    // messages in transit.
    while actor.is_running(|| generated_tx.mark_closed()) { //#!#//
        // SendSaturation::AwaitForRoom provides automatic backpressure management.
        // The actor will pause here if the receiving channel is full, preventing memory exhaustion
        // while maintaining data ordering and system stability. AwaitForRoom will return 
        // immediately if a shutdown signal is received.
        match actor.send_async(&mut generated_tx, state.value, SendSaturation::AwaitForRoom).await { //#!#//
            SendOutcome::Success => state.value += 1,
            SendOutcome::Blocked(_value) => {} // Only happens on shutdown 
        };
    }
    Ok(())
}

/// Unit test demonstrates isolated actor testing without requiring a full graph.
/// This pattern enables rapid development cycles and precise behavioral verification.
#[cfg(test)]
pub(crate) mod generator_tests {
    use steady_state::*;
    use crate::arg::MainArg;
    use super::*;

    #[test]
    fn test_generator() -> Result<(), Box<dyn Error>> {
        // Special GraphBuilder for testing is used here.
        let mut graph = GraphBuilder::for_testing().build(MainArg::default()); //#!#//
        let (generate_tx, generate_rx) = graph.channel_builder().build();

        let state = new_state();
        graph.actor_builder()//#!#//
            .with_name("UnitTest")
            //NOTE: we call internal_behavior() directly here, not run() which is now a simulation.
            .build(move |context| internal_behavior(context, generate_tx.clone(), state.clone()), SoloAct );

        graph.start();
        // Timing-based testing requires careful coordination between test duration
        // and expected actor behavior to ensure deterministic results.
        std::thread::sleep(Duration::from_millis(100));
        graph.request_shutdown();

        graph.block_until_stopped(Duration::from_secs(1))?;

        // Deterministic testing: predictable message sequences.
        assert_steady_rx_eq_take!(generate_rx,vec!(0,1));  //#!#//
        Ok(())
    }
}
